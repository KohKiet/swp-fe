import axios from 'axios';
import { API_CONFIG } from './apiConfig';

// L·∫•y URL base t·ª´ bi·∫øn m√¥i tr∆∞·ªùng ho·∫∑c m·∫∑c ƒë·ªãnh
const API_URL = process.env.REACT_APP_API_URL || API_CONFIG.BASE_URL;

// Helper function ƒë·ªÉ t·∫°o headers v·ªõi token
const getHeaders = () => {
  const token = localStorage.getItem('accessToken');
  const headers = {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  return headers;
};

// Helper function ƒë·ªÉ th·ª±c hi·ªán API call
const apiCall = async (method, endpoint, data = null) => {
  try {
    const config = {
      method,
      url: `${API_URL}${endpoint}`,
      headers: getHeaders(),
      timeout: 10000, // 10 second timeout
    };
    
    if (data) {
      config.data = data;
    }
    
    console.log(`üöÄ API Call: ${method} ${config.url}`, {
      headers: config.headers,
      data: data
    });
    
    const response = await axios(config);
    
    console.log(`‚úÖ API Response: ${method} ${config.url}`, {
      status: response.status,
      data: response.data
    });
    
    return response.data;
  } catch (error) {
    console.error(`‚ùå API Error: ${method} ${API_URL}${endpoint}`, {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      message: error.message,
      code: error.code
    });
    
    // X·ª≠ l√Ω l·ªói 401 (token h·∫øt h·∫°n)
    if (error.response?.status === 401) {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('userEmail');
      localStorage.removeItem('userFullname');
      localStorage.removeItem('userRole');
      localStorage.removeItem('userId');
      localStorage.removeItem('userPhone');
      localStorage.removeItem('userGender');
      localStorage.removeItem('userDateOfBirth');
      localStorage.removeItem('userAddress');
      window.location.href = '/login';
    }
    throw error;
  }
};

const eventService = {  // L·∫•y t·∫•t c·∫£ s·ª± ki·ªán
  getAllEvents: async () => {
    try {
      const response = await apiCall('GET', API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS);
      return response;
    } catch (error) {
      console.error('Error fetching all events:', error);
      throw error;
    }
  },

  // L·∫•y s·ª± ki·ªán s·∫Øp di·ªÖn ra
  getUpcomingEvents: async () => {
    try {      const response = await apiCall('GET', API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS_UPCOMING);
      return response;
    } catch (error) {
      console.error('Error fetching upcoming events:', error);
      throw error;
    }
  },

  // L·∫•y s·ª± ki·ªán ƒë√£ k·∫øt th√∫c
  getPastEvents: async () => {
    try {      const response = await apiCall('GET', API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS_PAST);
      return response;
    } catch (error) {
      console.error('Error fetching past events:', error);
      throw error;
    }
  },
  // L·∫•y s·ª± ki·ªán theo ID
  getEventById: async (id) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS_BY_ID.replace('{id}', id);      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error fetching event ${id}:`, error);
      throw error;
    }
  },

  // L·∫•y s·ª± ki·ªán c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i
  getMyEvents: async () => {
    try {
      const response = await apiCall('GET', API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS_MY_EVENTS);
      return response;
    } catch (error) {
      console.error('Error fetching my events:', error);
      throw error;
    }
  },

  // T·∫°o s·ª± ki·ªán m·ªõi
  createEvent: async (eventData) => {
    try {
      const response = await apiCall('POST', API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS, eventData);
      return response;
    } catch (error) {
      console.error('Error creating event:', error);
      throw error;
    }
  },

  // C·∫≠p nh·∫≠t s·ª± ki·ªán
  updateEvent: async (id, eventData) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS_BY_ID.replace('{id}', id);
      const response = await apiCall('PUT', endpoint, eventData);
      return response;
    } catch (error) {
      console.error(`Error updating event ${id}:`, error);
      throw error;
    }
  },

  // X√≥a s·ª± ki·ªán
  deleteEvent: async (id) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.COMMUNITY_EVENTS_BY_ID.replace('{id}', id);
      const response = await apiCall('DELETE', endpoint);
      return response;
    } catch (error) {
      console.error(`Error deleting event ${id}:`, error);
      throw error;
    }
  },

  // ƒêƒÉng k√Ω tham gia s·ª± ki·ªán
  registerForEvent: async (eventId) => {
    try {
      const response = await apiCall('POST', API_CONFIG.ENDPOINTS.EVENT_PARTICIPANTS_REGISTER, {
        eventId: eventId
      });
      return response;
    } catch (error) {
      console.error(`Error registering for event ${eventId}:`, error);
      throw error;
    }
  },

  // H·ªßy ƒëƒÉng k√Ω tham gia s·ª± ki·ªán
  unregisterFromEvent: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_PARTICIPANTS_UNREGISTER.replace('{eventId}', eventId);
      const response = await apiCall('DELETE', endpoint);
      return response;
    } catch (error) {
      console.error(`Error unregistering from event ${eventId}:`, error);
      throw error;
    }
  },  // Ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng k√Ω
  checkRegistrationStatus: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_PARTICIPANTS_CHECK_REGISTRATION.replace('{eventId}', eventId);
      console.log('üîç Calling registration check API:', {
        endpoint: `${API_URL}${endpoint}`,
        eventId: eventId,
        headers: getHeaders()
      });
      
      const response = await apiCall('GET', endpoint);
      
      console.log('üì° Registration check API response:', {
        endpoint: endpoint,
        response: response,
        responseType: typeof response,
        responseKeys: Object.keys(response || {}),
        dataKeys: Object.keys(response?.data || {}),
        fullStructure: JSON.stringify(response, null, 2)
      });
      
      // Normalize response structure ƒë·ªÉ ƒë·∫£m b·∫£o consistent
      let normalizedResponse = {
        success: response?.success || (response?.data !== undefined),
        data: {
          isRegistered: false // default
        }
      };
      
      // Ki·ªÉm tra c√°c pattern response kh√°c nhau t·ª´ backend
      if (response?.data?.isRegistered !== undefined) {
        // Pattern 1: { success: true, data: { isRegistered: true/false } }
        normalizedResponse.data.isRegistered = Boolean(response.data.isRegistered);
      } else if (response?.isRegistered !== undefined) {
        // Pattern 2: { success: true, isRegistered: true/false }
        normalizedResponse.data.isRegistered = Boolean(response.isRegistered);
      } else if (response?.data === true || response?.data === false) {
        // Pattern 3: { success: true, data: true/false }
        normalizedResponse.data.isRegistered = Boolean(response.data);
      } else if (typeof response?.data === 'object' && response?.data !== null) {
        // Pattern 4: Check if object has registration info
        const hasRegistration = response.data.registered || response.data.isParticipant || response.data.joined;
        normalizedResponse.data.isRegistered = Boolean(hasRegistration);
      }
      
      console.log('üìã Normalized registration response:', {
        original: response,
        normalized: normalizedResponse,
        finalStatus: normalizedResponse.data.isRegistered
      });
      
      return normalizedResponse;
    } catch (error) {
      console.error(`‚ùå Error checking registration status for event ${eventId}:`, {
        error: error,
        status: error.response?.status,
        data: error.response?.data,
        message: error.message
      });
      throw error;
    }
  },

  // ========== EVENT FEEDBACK FUNCTIONS ==========

  // L·∫•y feedback theo event ID
  getFeedbackByEvent: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_BY_EVENT.replace('{eventId}', eventId);
      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error fetching feedback for event ${eventId}:`, error);
      throw error;
    }
  },

  // L·∫•y feedback c·ªßa user hi·ªán t·∫°i
  getMyFeedback: async () => {
    try {
      const response = await apiCall('GET', API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_BY_USER);
      return response;
    } catch (error) {
      console.error('Error fetching my feedback:', error);
      throw error;
    }
  },

  // Ki·ªÉm tra user ƒë√£ ƒë√°nh gi√° event ch∆∞a
  checkUserFeedbackStatus: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_CHECK_USER.replace('{eventId}', eventId);
      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error checking feedback status for event ${eventId}:`, error);
      
      // N·∫øu endpoint kh√¥ng t·ªìn t·∫°i, return default response
      if (error.response?.status === 404 || error.response?.status === 405) {
        console.log('Feedback check endpoint not available, assuming no existing feedback');
        return {
          success: true,
          data: null // No existing feedback
        };
      }
      
      throw error;
    }
  },

  // G·ª≠i feedback cho event
  submitFeedback: async (feedbackData) => {
    try {
      // Debug: Log the exact request details
      console.log('üîç Submitting feedback with details:', {
        eventId: feedbackData?.eventId,
        rating: feedbackData?.rating,
        comment: feedbackData?.comment?.substring(0, 50) + '...',
        endpoint: API_CONFIG.ENDPOINTS.EVENT_FEEDBACK,
        fullUrl: `${API_URL}${API_CONFIG.ENDPOINTS.EVENT_FEEDBACK}`,
        payload: feedbackData
      });
      
      // S·ª≠ d·ª•ng endpoint ch√≠nh t·ª´ Swagger: POST /api/event-feedback
      const response = await apiCall('POST', API_CONFIG.ENDPOINTS.EVENT_FEEDBACK, feedbackData);
      console.log('‚úÖ Feedback submitted successfully:', response);
      return response;
      
    } catch (error) {
      console.error('‚ùå Error submitting feedback:', {
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        message: error.message,
        payload: feedbackData
      });
      throw error;
    }
  },

  // C·∫≠p nh·∫≠t feedback
  updateFeedback: async (id, feedbackData) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_BY_ID.replace('{id}', id);
      const response = await apiCall('PUT', endpoint, feedbackData);
      return response;
    } catch (error) {
      console.error(`Error updating feedback ${id}:`, error);
      
      // N·∫øu endpoint update kh√¥ng c√≥, th·ª≠ t·∫°o m·ªõi
      if (error.response?.status === 404 || error.response?.status === 405) {
        console.log('Update endpoint not available, trying to submit as new feedback');
        return await eventService.submitFeedback(feedbackData);
      }
      
      throw error;
    }
  },

  // ========== STAFF FEEDBACK MANAGEMENT FUNCTIONS ==========

  // L·∫•y t·∫•t c·∫£ feedback (cho Staff/Admin)
  getAllFeedback: async () => {
    try {
      const response = await apiCall('GET', API_CONFIG.ENDPOINTS.EVENT_FEEDBACK);
      return response;
    } catch (error) {
      console.error('Error fetching all feedback:', error);
      throw error;
    }
  },

  // L·∫•y feedback theo ID (cho Staff/Admin)
  getFeedbackById: async (feedbackId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_BY_ID.replace('{id}', feedbackId);
      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error fetching feedback ${feedbackId}:`, error);
      throw error;
    }
  },

  // X√≥a feedback (cho Staff/Admin)
  deleteFeedback: async (feedbackId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_BY_ID.replace('{id}', feedbackId);
      const response = await apiCall('DELETE', endpoint);
      return response;
    } catch (error) {
      console.error(`Error deleting feedback ${feedbackId}:`, error);
      throw error;
    }
  },

  // L·∫•y th·ªëng k√™ ƒë√°nh gi√° trung b√¨nh cho event
  getEventAverageRating: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_AVERAGE_RATING.replace('{eventId}', eventId);
      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error fetching average rating for event ${eventId}:`, error);
      throw error;
    }
  },

  // L·∫•y s·ªë l∆∞·ª£ng ƒë√°nh gi√° cho event
  getEventFeedbackCount: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_FEEDBACK_COUNT.replace('{eventId}', eventId);
      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error fetching feedback count for event ${eventId}:`, error);
      throw error;
    }
  },

  // L·∫•y danh s√°ch ng∆∞·ªùi tham gia event (cho Staff/Admin)
  getEventParticipants: async (eventId) => {
    try {
      const endpoint = API_CONFIG.ENDPOINTS.EVENT_PARTICIPANTS_BY_EVENT.replace('{eventId}', eventId);
      const response = await apiCall('GET', endpoint);
      return response;
    } catch (error) {
      console.error(`Error fetching participants for event ${eventId}:`, error);
      throw error;
    }
  }
};

export default eventService;
